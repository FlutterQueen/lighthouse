import 'dart:io';

import 'package:df_builder/df_builder.dart';
import 'package:lighthouse/src/helpers/file.dart';
import 'package:lighthouse/src/helpers/string.dart';
import 'package:recase/recase.dart';

import 'package:args/command_runner.dart';

import '../enums.dart';

/// return supported locales based on files names
List<String> supportedLocales(List<File> files) {
  return files
      .map((f) => f.path.split('/').last.replaceAll('.json', ''))
      .toList();
}

List<String> keyMissingLangs(
    {required String key,
    required Map<String, Map<String, dynamic>> langsAssets,
    required List<String> supportedLangs,
    }) {
  final missingList = <String>[];
  for (final lang in supportedLangs) {
    // TODO :: supporte nested
    final keyExist = langsAssets[lang]!.containsKey(key);
    if (!keyExist) {
      missingList.add(key);
    }
  }
  return missingList;
}

class TR extends Command {
  @override
  String get description => 'Creates the generated translation files/assets';
  @override
  String get name => 'tr:make';

  @override
  Future<void> run() async {
    final jsonAssets = await loadDirectoryFiles('./assets/lang/');
    final languages = supportedLocales(jsonAssets);
    final langAssets =<String,Map<String,dynamic>>{};
    for(final lang in languages){
      langAssets[lang] =  await readJsonContent('./assets/lang/$lang.json');
    }
    // print(langAssets['ar']!['date']);
    // print(langAssets['en']!['date']);
    

    final dfBulder = DartFileBuilder(
      imports: ["import 'package:nations/nations.dart';"],
      topComments: ['/// ! This File is Generated by LH DO NOT EDIT ðŸ‘‘'],
      name: 'nations_gen.dart',
      path: '',
    );

    final trGetters = buildClassGetters(map: langAssets, dfBuilder: dfBulder);

    dfBulder.addClass(ClassBuilder(
      name: 'Tr',
      havePrivateConstractor: true,
      getters: trGetters,
    ));

    /// generateed files
    if (!Directory('./lib/generated').existsSync()) {
      await Directory('./lib/generated').create();
    }
    final genFile = File('./lib/generated/tr.dart');
    if (await genFile.exists()) await genFile.delete();
    await genFile.writeAsString(dfBulder.toString());
    // await genFile.writeAsString('$interfacesBuffer \n $cBuilder ');
    // TODO :: format file after its generated
  }
}

ClassBuilder buildInterface(
  String key,
  Map<String, dynamic> map,
  DartFileBuilder dfBuilder, {
  List<String> parents = const [],
}) {
  final getters = buildClassGetters(
    map: {'ar':map},
    dfBuilder: dfBuilder,
    parents: parents,
    useStaticGetters: false,
  );

  return ClassBuilder(
    havePrivateConstractor: false,
    name: buildInterfaceName(key),
    classProps: [
      ClassProp(
        addToConstructor: true,
        name: 'key',
        type: 'String',
      )
    ],
    getters: getters,
  );
}

String buildInterfaceName(String key) => '_${key.pascalCase}Interface';

List<ClassGetter> buildClassGetters({
  List<String> parents = const [],
  required Map<String,Map<String, dynamic>> map,
  required DartFileBuilder dfBuilder,
  bool useStaticGetters = true,
}) {
  final getters = <ClassGetter>[];
  for (final key in map.values.first.keys) {
    final newParents = [...parents, key];
    switch (feildType(map[key])) {
      case ValueType.string:
       
        getters.add(
          ClassGetter(
         //    deprecatedMessage:_buildGetterDepMsg(),
            comments: '  // * `$key` => `ar` ',
            isStatic: useStaticGetters,
            name: key,
            type: 'String',
            whatToReturn: buildKeyWithParents(key, newParents),
          ),
        );
        break;
      case ValueType.gender:
      case ValueType.nested:
        dfBuilder.addClass(
          buildInterface(key, map.values.first[key], dfBuilder, parents: newParents),
        );
        getters.add(
          ClassGetter(
            comments: '// * Foo ',
            isStatic: useStaticGetters,
            name: key,
            type: buildInterfaceName(key),
            whatToReturn: "${buildInterfaceName(key)}('$key')",
          ),
        );

        break;
    }
  }
  return getters;
}

String buildKeyWithParents(String key, List<String> parents) {
  if (parents.length < 2) {
    return "'$key'.tr";
  } else {
    final buf = StringBuffer();
    for (final p in parents) {
      buf.write(p);
      if (parents.last != p) buf.write('.');
    }

    return "'${buf.toString()}'.tr";
  }
}
