import 'dart:io';

import 'package:df_builder/df_builder.dart';
import 'package:lighthouse/src/helpers/file.dart';
import 'package:lighthouse/src/helpers/locale.dart';
import 'package:lighthouse/src/helpers/string.dart';
import 'package:recase/recase.dart';

import 'package:args/command_runner.dart';

import '../../enums.dart';

class TR extends Command {
  @override
  String get description => 'Creates the generated translation files/assets';
  @override
  String get name => 'tr:make';

  @override
  Future<void> run() async {
    final jsonAssets = await loadDirectoryJsonFiles('./assets/lang/');
    final languages = supportedLocales(jsonAssets);
    final langAssets = <String, Map<String, dynamic>>{};
    final keys = <String>{};
    for (final lang in languages) {
      langAssets[lang] = await readJsonContent('./assets/lang/$lang.json');
      keys.addAll(langAssets[lang]!.keys.toList());
    }
    for (final key in keys) {
      findMissingKeys(
        key: key,
        langsAssets: langAssets,
        supportedLangs: languages,
      );
    }

    final dfBuilder = DartFileBuilder(
      imports: ["import 'package:nations/nations.dart';"],
      topComments: ['/// ! This File is Generated by LH DO NOT EDIT ðŸ‘‘'],
      name: 'nations_gen.dart',
      path: '',
    );
    final trGetters = buildClassGetters(map: langAssets, dfBuilder: dfBuilder);

    dfBuilder.addClass(ClassBuilder(
      name: 'Tr',
      havePrivateConstructor: true,
      getters: trGetters,
    ));

    /// generated files
    if (!Directory('./lib/generated').existsSync()) {
      await Directory('./lib/generated').create();
    }
    final genFile = File('./lib/generated/tr.dart');
    if (await genFile.exists()) await genFile.delete();
    await genFile.writeAsString(dfBuilder.toString());
    // await genFile.writeAsString('$interfacesBuffer \n $cBuilder ');
  }
}

ClassBuilder buildInterface(
  String key,
  Map<String, dynamic> map,
  DartFileBuilder dfBuilder, {
  List<String> parents = const [],
}) {
  final getters = buildClassGetters(
    map: {'ar': map},
    dfBuilder: dfBuilder,
    parents: parents,
    useStaticGetters: false,
  );

  return ClassBuilder(
    havePrivateConstructor: false,
    name: buildInterfaceName(key),
    classProps: [
      ClassProp(
        addToConstructor: true,
        name: 'key',
        type: 'String',
      )
    ],
    getters: getters,
  );
}

String buildInterfaceName(String key) => '_${key.pascalCase}Interface';

List<ClassGetter> buildClassGetters({
  List<String> parents = const [],
  required Map<String, Map<String, dynamic>> map,
  required DartFileBuilder dfBuilder,
  bool useStaticGetters = true,
}) {
  final getters = <ClassGetter>[];
  for (final key in map.values.first.keys) {
    final newParents = [...parents, key];
    switch (validateFelidType(key: key, value: map.values.first[key])) {
      case ValueType.string:
        getters.add(
          ClassGetter(
            //    deprecatedMessage:_buildGetterDepMsg(),
            comments: buildKeyComments(key, map),
            isStatic: useStaticGetters,
            name: key,
            type: 'String',
            whatToReturn: buildKeyWithParents(key, newParents),
          ),
        );
        break;
      case ValueType.gender:
      case ValueType.nested:
        dfBuilder.addClass(
          buildInterface(key, map.values.first[key], dfBuilder,
              parents: newParents),
        );
        getters.add(
          ClassGetter(
            comments: '/// * Nested ',
            isStatic: useStaticGetters,
            name: key,
            type: buildInterfaceName(key),
            whatToReturn: "${buildInterfaceName(key)}('$key')",
          ),
        );

        break;
    }
  }
  return getters;
}

String buildKeyComments(String key, Map<String, Map<String, dynamic>> first) {
  final buffer = StringBuffer();
  for (final lang in first.keys) {
    // buffer.write('lang is $lang \n');
    buffer.writeln('  /// * `$lang` => `${first[lang]![key]}` ');
  }
  return buffer.toString();
}

String buildKeyWithParents(String key, List<String> parents) {
  if (parents.length < 2) {
    return "'$key'.tr";
  } else {
    final buf = StringBuffer();
    for (final p in parents) {
      buf.write(p);
      if (parents.last != p) buf.write('.');
    }

    return "'${buf.toString()}'.tr";
  }
}
