import 'dart:io';

import 'package:lighthouse/src/helpers/file.dart';
import 'package:lighthouse/src/helpers/string.dart';
import 'package:lighthouse/src/utils/class_builder.dart';
import 'package:recase/recase.dart';
import '../../command.dart';
import '../../enums.dart';

// ignore: constant_identifier_names
const _GENDER_INTERFACE = '''
class _GenderInterface {
  final String key;
  _GenderInterface(this.key);
  String get male => key.trMale;
  String get feMale => key.trFemale;
  String get defaultGender => key.gender;
}
''';

class MakeLocaleCommand extends LightHouseCommand {
  @override
  Future<void> handle(Iterable<String> args) async {
    // TODO :: validate in check more than one file
    await loadDirectoryFiles('./assets/lang');

    final content = await readJsonContent('./assets/lang/ar.json');

    final cBuilder = ClassBuilder(name: 'Tr');

    final interfacesBuffer = StringBuffer('''
    /// ! This File is Generated by LH DO NOT EDIT ðŸ‘‘
    import 'package:nations/nations.dart';
    $_GENDER_INTERFACE
      ''');

    cBuilder.addGettersList(
      _buildMap(map: content, interfacesBuffer: interfacesBuffer),
    );

    /// generateed files
    final genFile = File('./assets/lang/ar.dart');
    if (await genFile.exists()) await genFile.delete();
    await genFile.writeAsString('$interfacesBuffer \n $cBuilder ');
    // TODO :: format file after its generated
  }
}

String _buildInterface(
  String key,
  Map<String, dynamic> map,
  StringBuffer interfacesBuffer,
) {
  final buffer = StringBuffer();
  _buildMap(
          map: map, interfacesBuffer: interfacesBuffer, useStaticGetters: false)
      .forEach(buffer.writeln);
  return '''
class ${_buildInterfaceName(key)} {
  final String key;
  const ${_buildInterfaceName(key)}(this.key);
   $buffer
                               }
  ''';
}

String _buildInterfaceName(String key) {
  return '_${key.pascalCase}Interface';
}

List<ClassGetter> _buildMap({
  required Map<String, dynamic> map,
  required StringBuffer interfacesBuffer,
  bool useStaticGetters = true,
}) {
  final getters = <ClassGetter>[];
  for (final key in map.keys) {
    switch (feildType(map[key])) {
      case ValueType.string:
        getters.add(
          ClassGetter(
            isStatic: useStaticGetters,
            name: key,
            returnType: 'String',
            whatToReturn: "'$key'.tr",
          ),
        );
        break;
      case ValueType.gender:
        getters.add(
          ClassGetter(
            isStatic: useStaticGetters,
            name: key,
            returnType: '_GenderInterface',
            whatToReturn: "_GenderInterface('$key')",
          ),
        );
        break;
      case ValueType.nested:
        getters.add(
          ClassGetter(
            isStatic: useStaticGetters,
            name: key,
            returnType: _buildInterfaceName(key),
            whatToReturn: "${_buildInterfaceName(key)}('$key')",
          ),
        );
        interfacesBuffer.writeln(
          _buildInterface(key, map[key], interfacesBuffer),
        );
        break;
    }
  }
  return getters;
}
